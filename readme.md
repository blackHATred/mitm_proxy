# Домашнее задание по курсу "Безопасность Web-приложений"

## Ссылки
- [Описание выполненного задания](#описание-выполненного-задания)
- [Как запустить](#как-запустить)
- [Примеры](#примеры)

## Описание выполненного задания
Выполненный проект представляет собой простой прокси-сервер c Man-in-the-Middle со встроенным сканнером param miner.  
Реализованные фичи:
- Прокси-сервер, который перенаправляет запросы на указанный адрес и сохраняет их в базу данных вместе с полученным ответом;
- Встроенный генератор сертификатов для HTTPS;
    - При первом обращении к указанному домену генерируется самоподписанный сертификат на основе корневого;
    - Все сгенерированные сертификаты сохраняются в mongodb для дальнейшего переиспользования;
> Если в параметрах системы указать приложение в качестве прокси, то браузер будет предупреждать о небезопасном соединении;
- Веб-приложение для просмотра истории запросов;
    - ```/requests/``` - отображает список всех запросов в виде таблицы с id запросов и временем их отправки;
    - ```/requests/<id>``` - отображает информацию о запросе с указанным id, при этом отдельно парсит параметры 
(включая POST-параметры в форме) и передаваемые cookies;
    - ```/repeat/<id>``` - повторяет запрос с указанным id и перенаправляет на страницу с результатом склонированного 
запроса;
    - ```/scan/<id>``` - запускает param miner для запроса с указанным id и через chunked transfer encoding выводит 
результаты сканирования или ошибку (например, если разорвано соединение или конечный сервер ограничивает количество 
запросов);
    - ```/``` - dummy endpoint, который возвращает ```Hello, World!``` или значение параметра ```url``` из запроса - 
необходим для проверки работы param miner;
- Для удобной визуализации и анализа запросов прокси-сервер удаляет заголовок ```Accept-Encoding```, что исключает сжатие ответа;
- Прокси-сервер удаляет заголовок ```Proxy-Connection```;
- Param miner ищет параметры из URL, значения которых встречаются в теле ответа, и выводит их в виде таблицы;

## Как запустить
Перед запуском проекта следует сгенерировать public и private сертификаты с помощью ```make gen-ca``` или сделать это
вручную иным методом.  
Для запуска проекта можно использовать команду ```docker-compose up --d```, сгенерированные с помощью makefile 
сертификаты будут скопированы внутрь контейнера автоматически. При стандартной конфигурации прокси-сервер будет работать
по адресу http://localhost:8000, а веб-приложение для взаимодействия с историей запросов по адресу 
http://localhost:8080/requests.  

Чтобы изменить список параметров для param miner, необходимо отредактировать файл ```resources/params.txt```.  

Для изменения конфигурации приложения (если оно запускается не через docker compose) можно использовать следующие флаги:
- ```-db``` - адрес для подключения к mongodb, по умолчанию ```mongodb://localhost:27017```;
- ```-proxy``` - адрес, на котором будет работать веб-приложение, по умолчанию ```:8000```;
- ```-web``` - адрес, на котором будет работать прокси-сервер, по умолчанию ```:8080```;
- ```-ca-key``` - путь до корневого private сертификата;
- ```-ca-cert``` - путь до корневого public сертификата.

## Примеры
В дальнейшем вместе с curl будут использованы следующие флаги:
- ```-k``` - отключает проверку сертификата (при использовании самоподписанного сертификата);
- ```-i``` - выводит заголовки ответа;
- ```-x``` - указывает прокси-сервер.
- ```-X``` - указывает метод запроса;
- ```-H``` - добавляет заголовок;
- ```-d``` - добавляет тело запроса.

Примеры:
- Простой GET-запрос http:  
  ```curl -i -x http://127.0.0.1:8000 http://mail.ru```  
  Должен вернуться ответ примерно следующего вида:
  ```
  HTTP/1.1 301 Moved Permanently
  Content-Length: 169
  Connection: keep-alive
  Content-Type: text/html
  Date: Fri, 27 Sep 2024 17:29:08 GMT
  Location: https://mail.ru/
  Server: nginx/1.25.3
  
  <html>
  <head><title>301 Moved Permanently</title></head>
  <body>
  <center><h1>301 Moved Permanently</h1></center>
  <hr><center>nginx/1.25.3</center>
  </body>
  </html>
  ```

- Простой GET-запрос https:  
  ```curl -k -i -x http://127.0.0.1:8000 https://mail.ru | head -n 20```  
  Должен вернуться ответ примерно следующего вида:
  ```
  HTTP/1.1 200 Connection Established
  
  HTTP/1.1 200 OK
  Transfer-Encoding: chunked
  Cache-Control: no-cache,no-store,must-revalidate
  Connection: keep-alive
  ...
  
  
  <!DOCTYPE html>
  ...
  ```

- Запрос типа POST с параметрами:  
  ```curl -k -x http://127.0.0.1:8000 -X POST "https://httpbin.org/anything" -H "accept: application/json" -H "Content-Type: application/json" -d '{"param1":"value1","param2":"value2"}'```  
  Должен вернуться ответ примерно следующего вида:
  ```
  {
    "args": {}, 
    "data": "{\"param1\":\"value1\",\"param2\":\"value2\"}", 
    "files": {}, 
    "form": {}, 
    "headers": {
      "Accept": "application/json", 
      "Content-Length": "37", 
      "Content-Type": "application/json", 
      "Host": "httpbin.org", 
      "User-Agent": "curl/8.7.1", 
    }, 
    "json": {
      "param1": "value1", 
      "param2": "value2"
    }, 
    "method": "POST", 
    "url": "https://httpbin.org/anything"
  }
  ```

- GET-запрос на нестандартный порт:  
```curl -i -x http://127.0.0.1:8000 http://127.0.0.1:8080```  
  Должен вернуться ответ примерно следующего вида:  
  ```
  HTTP/1.1 200 OK
  Content-Length: 13
  Content-Type: text/plain; charset=utf-8
  Date: Sat, 28 Sep 2024 10:04:04 GMT
  
  Hello, World!
  ```
  Если найти этот запрос в списке и начать сканирование param miner, то найдется скрытый параметр ```url```.  
  Удостоверимся в этом, отправив запрос:  
  ```curl -i -x http://127.0.0.1:8000 http://127.0.0.1:8080?url=vulnerability```  
  Должен вернуться ответ примерно следующего вида:
  ```
  HTTP/1.1 200 OK
  Content-Length: 13
  Content-Type: text/plain; charset=utf-8
  Date: Sat, 28 Sep 2024 10:05:04 GMT
  
  vulnerability
  ```
  Как можно заметить, тело ответа поменялось и теперь в нём можно обнаружить переданный query-параметр.

- Для проверки работы cookies легче использовать браузер. Можно добавить прокси-сервер в настройках браузера или системы
и перейти на любой сайт. Браузер может предупредить о небезопасном соединении, так как используется самоподписанный 
сертификат.
